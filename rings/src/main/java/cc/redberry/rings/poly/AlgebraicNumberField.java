package cc.redberry.rings.poly;

import cc.redberry.rings.poly.univar.IUnivariatePolynomial;
import cc.redberry.rings.poly.univar.UnivariateDivision;
import cc.redberry.rings.poly.univar.UnivariateGCD;

/**
 * Algebraic number field.
 *
 * @see FiniteField
 */
public class AlgebraicNumberField<Poly extends IUnivariatePolynomial<Poly>>
        extends UnivariateQuotientRing<Poly> {
    /**
     * Constructs algebraic extension of field generated by the root of given irreducible polynomial.
     */
    @SuppressWarnings("unchecked")
    public AlgebraicNumberField(Poly minimalPoly) {
        super(minimalPoly);
        if (minimalPoly.isOverFiniteField())
            throw new IllegalArgumentException("Use FiniteField for constructing extensions of finite fields.");
    }

    /**
     * Returns whether a given element of number field is a plain number (doesn't involve algebraic elements)
     */
    public boolean isSimpleNumber(Poly e) {
        return e.isConstant();
    }

    @Override
    public boolean isField() {return minimalPoly.isOverField();}

    @Override
    public boolean isUnit(Poly element) {
        return (isField() && !isZero(element)) || (isOne(element) || isMinusOne(element));
    }

    @Override
    public Poly gcd(Poly a, Poly b) {
        // NOTE: don't change this
        return isField() ? a : UnivariateGCD.PolynomialGCD(a, b);
    }

    @Override
    public Poly[] divideAndRemainder(Poly a, Poly b) {
        if (isField())
            return createArray(multiply(a, reciprocal(b)), getZero());

        Poly[] cancel = cancellingMultiplier2(b);
        Poly cb = cancel[0];
        Poly bcb = cancel[1];

        Poly pseudoQuot = multiply(a, cb);
        Poly quot = pseudoQuot.clone().divideByLC(bcb);
        if (quot != null)
            return createArray(quot, getZero());

        return UnivariateDivision.divideAndRemainder(a, b, true);
    }

    @Override
    public Poly remainder(Poly dividend, Poly divider) {
        return divideAndRemainder(dividend, divider)[1];
    }

    public Poly cancellingMultiplier(Poly element) {
        return cancellingMultiplier2(element)[0];
    }

    public Poly[] cancellingMultiplier2(Poly element) {
        if (isField())
            return createArray(reciprocal(element), getOne());

        if (element.isZero())
            throw new ArithmeticException("divide by zero");
        if (isOne(element))
            return createArray(element, getOne());
        if (isMinusOne(element))
            return createArray(element, getOne());

        Poly[] xgcd = UnivariateGCD.PolynomialExtendedGCD(element, minimalPoly);
        Poly conjugate = xgcd[1];
        Poly content = conjugate.contentAsPoly();
        return createArray(conjugate.divideByLC(content), xgcd[0].divideByLC(content));
    }
}
