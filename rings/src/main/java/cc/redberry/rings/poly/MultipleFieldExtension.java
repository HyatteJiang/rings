package cc.redberry.rings.poly;

import cc.redberry.rings.ImageRing;
import cc.redberry.rings.Rings;
import cc.redberry.rings.bigint.BigInteger;
import cc.redberry.rings.poly.multivar.AMonomial;
import cc.redberry.rings.poly.multivar.AMultivariatePolynomial;
import cc.redberry.rings.poly.multivar.MultivariateResultants;
import cc.redberry.rings.poly.univar.IUnivariatePolynomial;
import cc.redberry.rings.poly.univar.UnivariateGCD;
import cc.redberry.rings.poly.univar.UnivariatePolynomial;
import cc.redberry.rings.poly.univar.UnivariateSquareFreeFactorization;
import cc.redberry.rings.util.ArraysUtil;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;

/**
 * Multiple field extension {@code F(α_1, α_2, ..., α_N)}. Elements are represented as multivariate polynomials over
 * {@code (α_1, α_2, ..., α_N)}; internally all arithmetic operations are performed by switching to appropriate simple
 * field extension {@code F(γ)} (accessible via {@link #getSimpleExtension()} method) where {@code γ} is some primitive
 * element (accessible via {@link #getPrimitiveElement()} method) computed automatically. Representation of generating
 * algebraic elements {@code α_i} as elements of this simple extension can be obtained via {@link #getGeneratorRep(int)}
 * method. Originally, generators are represented by their minimal polynomials over F.
 *
 * @see #mkMultipleExtension(IUnivariatePolynomial[])
 * @since 2.5
 */
public class MultipleFieldExtension<
        Term extends AMonomial<Term>,
        mPoly extends AMultivariatePolynomial<Term, mPoly>,
        sPoly extends IUnivariatePolynomial<sPoly>
        > extends ImageRing<sPoly, mPoly> implements IPolynomialRing<mPoly> {
    /** multivariate polynomial factory */
    final mPoly mFactory;
    /** univariate polynomial factory */
    final sPoly sFactory;
    /** Generators of multiple field extension given by their minimal polynomials */
    final sPoly[] minimalPolynomialsOfGenerators;
    /** Primitive element that generates equivalent simple extension */
    final mPoly primitiveElement;
    /** Simple field extension generated by primitive element */
    final SimpleFieldExtension<sPoly> simpleExtension;
    /** Generators represented as elements of simple field extension */
    final sPoly[] generatorsReps;

    public MultipleFieldExtension(sPoly[] minimalPolynomialsOfGenerators,
                                  mPoly primitiveElement,
                                  sPoly[] generatorsReps,
                                  SimpleFieldExtension<sPoly> simpleExtension) {
        super(simpleExtension,
                new MultipleToSimple<>(primitiveElement, simpleExtension, generatorsReps),
                new SimpleToMultiple<>(primitiveElement, simpleExtension, generatorsReps));
        this.minimalPolynomialsOfGenerators = minimalPolynomialsOfGenerators;
        this.primitiveElement = primitiveElement;
        this.simpleExtension = simpleExtension;
        this.generatorsReps = generatorsReps;
        this.mFactory = primitiveElement.createOne();
        this.sFactory = simpleExtension.factory().createOne();
    }

    @Override
    public int nVariables() {
        return mFactory.nVariables;
    }

    @Override
    public mPoly factory() {
        return mFactory;
    }

    @Override
    public mPoly variable(int variable) {
        return mFactory.createMonomial(variable, 1);
    }

    public sPoly getUnivariateFactory() {
        return sFactory;
    }

    /**
     * Returns the primitive element of this multiple field extension
     */
    public mPoly getPrimitiveElement() {
        return primitiveElement.clone();
    }

    /**
     * Returns the isomorphic simple field extension generated by {@link #getPrimitiveElement()}
     */
    public SimpleFieldExtension<sPoly> getSimpleExtension() {
        return simpleExtension;
    }

    /**
     * Returns minimal polynomial corresponding to i-th generator.
     */
    public sPoly getGeneratorMinimalPoly(int iGenerator) {
        return minimalPolynomialsOfGenerators[iGenerator].clone();
    }

    /**
     * Returns representation of i-th generator as element of simple field extension generated by primitive element
     * {@link #getPrimitiveElement()}
     */
    public sPoly getGeneratorRep(int iGenerator) {
        return generatorsReps[iGenerator].clone();
    }

    /**
     * Adds algebraic element given by its minimal polynomial to this.
     */
    public MultipleFieldExtension<Term, mPoly, sPoly> adjoinAlgebraicElement(sPoly minimalPoly) {
        MultipleFieldExtension<Term, mPoly, sPoly> ext = mkMultipleExtension(simpleExtension.minimalPoly, minimalPoly);

        sPoly[] minimalPolynomialsOfGenerator = ArraysUtil.addAll(this.minimalPolynomialsOfGenerators, minimalPoly);
        mPoly primitiveElement = ext.primitiveElement
                .insertVariable(1, nVariables() - 1)
                .composition(0, this.primitiveElement.joinNewVariable());
        sPoly[] generatorsReps = Stream.concat(
                Arrays.stream(this.generatorsReps).map(rep -> rep.composition(ext.generatorsReps[0])),
                Stream.of(ext.generatorsReps[1])).toArray(sFactory::createArray);
        SimpleFieldExtension<sPoly> simpleExtension = ext.simpleExtension;

        return new MultipleFieldExtension<>(minimalPolynomialsOfGenerator, primitiveElement, generatorsReps, simpleExtension);
    }

    @Override
    public mPoly valueOf(long val) {
        return mFactory.createConstant(val);
    }

    @Override
    public mPoly valueOfBigInteger(BigInteger val) {
        return mFactory.createOne().multiplyByBigInteger(val);
    }

    @Override
    public mPoly valueOf(mPoly val) {
        return val;
    }

    @Override
    public mPoly getZero() {
        return mFactory.createZero();
    }

    @Override
    public mPoly getOne() {
        return mFactory.createOne();
    }

    @Override
    public mPoly addMutable(mPoly a, mPoly b) {
        return a.add(b);
    }

    @Override
    public mPoly subtractMutable(mPoly a, mPoly b) {
        return a.subtract(b);
    }

    @Override
    public mPoly negateMutable(mPoly element) {
        return element.negate();
    }

    @Override
    public mPoly add(mPoly a, mPoly b) {
        return a.clone().add(b);
    }

    @Override
    public mPoly subtract(mPoly a, mPoly b) {
        return a.clone().subtract(b);
    }

    @Override
    public mPoly negate(mPoly element) {
        return element.clone().negate();
    }

    @Override
    public mPoly increment(mPoly element) {
        return element.clone().increment();
    }

    @Override
    public mPoly decrement(mPoly element) {
        return element.clone().decrement();
    }

    @Override
    public mPoly add(mPoly... elements) {
        return getZero().add(elements);
    }

    @Override
    public mPoly copy(mPoly element) {
        return element.clone();
    }

    @Override
    public boolean isZero(mPoly element) {
        return element.isZero();
    }

    @Override
    public boolean isOne(mPoly element) {
        return element.isOne();
    }

    @Override
    public boolean isUnit(mPoly element) {
        return isField()
                ? !isZero(element)
                : (isOne(element) || isMinusOne(element));
    }

    @Override
    public mPoly gcd(mPoly a, mPoly b) {
        return isField() ? a.clone() : getOne();
    }

    @Override
    public mPoly[] extendedGCD(mPoly a, mPoly b) {
        return super.extendedGCD(a, b);
    }

    @Override
    public mPoly lcm(mPoly a, mPoly b) {
        return super.lcm(a, b);
    }

    @Override
    public mPoly gcd(mPoly... elements) {
        return super.gcd(elements);
    }

    @Override
    public mPoly gcd(Iterable<mPoly> elements) {
        return super.gcd(elements);
    }

    @Override
    public int signum(mPoly element) {
        return element.signumOfLC();
    }

    @Override
    public mPoly factorial(long num) {
        return super.factorial(num);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        MultipleFieldExtension<?, ?, ?> that = (MultipleFieldExtension<?, ?, ?>) o;
        return Arrays.equals(minimalPolynomialsOfGenerators, that.minimalPolynomialsOfGenerators);
    }

    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + Arrays.hashCode(minimalPolynomialsOfGenerators);
        return result;
    }

    static class MappingFunc<
            Term extends AMonomial<Term>,
            mPoly extends AMultivariatePolynomial<Term, mPoly>,
            sPoly extends IUnivariatePolynomial<sPoly>
            > implements Serializable {
        /** Primitive element that generates equivalent simple extension */
        final mPoly primitiveElement;
        /** Simple field extension generated by primitive element */
        final SimpleFieldExtension<sPoly> simpleExtension;
        /** Generators represented as elements of simple field extension */
        final sPoly[] generatorsReps;

        MappingFunc(mPoly primitiveElement, SimpleFieldExtension<sPoly> simpleExtension, sPoly[] generatorsReps) {
            this.primitiveElement = primitiveElement;
            this.simpleExtension = simpleExtension;
            this.generatorsReps = generatorsReps;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            MappingFunc<?, ?, ?> that = (MappingFunc<?, ?, ?>) o;
            return Objects.equals(primitiveElement, that.primitiveElement) &&
                    Arrays.equals(generatorsReps, that.generatorsReps);
        }

        @Override
        public int hashCode() {
            int result = Objects.hash(primitiveElement);
            result = 31 * result + Arrays.hashCode(generatorsReps);
            return result;
        }
    }

    static final class SimpleToMultiple<
            Term extends AMonomial<Term>,
            mPoly extends AMultivariatePolynomial<Term, mPoly>,
            sPoly extends IUnivariatePolynomial<sPoly>
            > extends MappingFunc<Term, mPoly, sPoly> implements Function<sPoly, mPoly> {
        SimpleToMultiple(mPoly primitiveElement, SimpleFieldExtension<sPoly> simpleExtension, sPoly[] generatorsReps) {
            super(primitiveElement, simpleExtension, generatorsReps);
        }

        @Override
        @SuppressWarnings("unchecked")
        public mPoly apply(sPoly sPoly) {
            return (mPoly) sPoly.composition(primitiveElement);
        }
    }

    static final class MultipleToSimple<
            Term extends AMonomial<Term>,
            mPoly extends AMultivariatePolynomial<Term, mPoly>,
            sPoly extends IUnivariatePolynomial<sPoly>
            > extends MappingFunc<Term, mPoly, sPoly> implements Function<mPoly, sPoly> {
        MultipleToSimple(mPoly primitiveElement, SimpleFieldExtension<sPoly> simpleExtension, sPoly[] generatorsReps) {
            super(primitiveElement, simpleExtension, generatorsReps);
        }

        @Override
        public sPoly apply(mPoly mPoly) {
            return mPoly.composition(simpleExtension, generatorsReps);
        }
    }

    @SuppressWarnings("unchecked")
    public static <
            Term extends AMonomial<Term>,
            mPoly extends AMultivariatePolynomial<Term, mPoly>,
            sPoly extends IUnivariatePolynomial<sPoly>
            > MultipleFieldExtension<Term, mPoly, sPoly>
    mkMultipleExtension(sPoly a) {
        sPoly[] ms = a.createArray(1);
        ms[0] = a;
        return new MultipleFieldExtension<>(ms, (mPoly) a.asMultivariate(), ms.clone(), Rings.mkSimpleExtension(a));
    }

    /**
     * Creates multiple field extension {@code F(α_1, α_2)} where {@code α_1} and {@code α_2} are specified by their
     * minimal polynomials over F.
     *
     * <p>NOTE: it is not tested that specified minimal polynomials are irreducible
     *
     * @param a minimal polynomial of the first algebraic number
     * @param b minimal polynomial of the second algebraic number
     */
    @SuppressWarnings("unchecked")
    public static <
            Term extends AMonomial<Term>,
            mPoly extends AMultivariatePolynomial<Term, mPoly>,
            sPoly extends IUnivariatePolynomial<sPoly>
            > MultipleFieldExtension<Term, mPoly, sPoly>
    mkMultipleExtension(sPoly a, sPoly b) {
        for (int s = 0; ; ++s) {
            // prepare a(x - s*y) and b(y) to compute resultant
            mPoly
                    ma = (mPoly) a.asMultivariate().setNVariables(2),
                    mb = (mPoly) b.asMultivariate().insertVariable(0),
                    factory = ma.createOne();
            if (s != 0)
                ma = ma.composition(0,
                        factory.createMonomial(0, 1)
                                .subtract(factory.createMonomial(1, 1).multiply(s)));

            sPoly primitiveElement = (sPoly) MultivariateResultants.Resultant(ma, mb, 1).asUnivariate();
            if (!UnivariateSquareFreeFactorization.isSquareFree(primitiveElement))
                continue;

            SimpleFieldExtension<sPoly> extension = Rings.mkSimpleExtension(primitiveElement);
            UnivariatePolynomial<sPoly>
                    aE = a.mapCoefficientsAsPolys(extension, extension::valueOf),
                    bE = b.mapCoefficientsAsPolys(extension, extension::valueOf);
            aE = aE.composition(aE.createConstant(extension.generator()).subtract(aE.createMonomial(1).multiply(s)));

            UnivariatePolynomial<sPoly> gcd = UnivariateGCD.PolynomialGCD(aE, bE).monic();
            assert gcd.degree() == 1;

            sPoly bRep = extension.negate(gcd.cc());
            sPoly aRep = extension.subtract(extension.generator(), bRep.clone().multiply(s));

            return new MultipleFieldExtension<>(a.createArray(a, b),
                    factory.createMonomial(0, 1).add(factory.createMonomial(1, 1).multiply(s)),
                    a.createArray(aRep, bRep), extension);
        }
    }

    /**
     * Creates multiple field extension {@code F(α_1, α_2, ..., α_i)} where {@code α_i} are specified by their minimal
     * polynomials over F.
     *
     * <p>NOTE: it is not tested that specified minimal polynomials are irreducible
     *
     * @param minimalPolynomials minimal polynomials of algebraic elements
     */
    @SuppressWarnings("unchecked")
    public static <
            Term extends AMonomial<Term>,
            mPoly extends AMultivariatePolynomial<Term, mPoly>,
            sPoly extends IUnivariatePolynomial<sPoly>
            > MultipleFieldExtension<Term, mPoly, sPoly>
    mkMultipleExtension(sPoly... minimalPolynomials) {
        MultipleFieldExtension<Term, mPoly, sPoly> ext = mkMultipleExtension(minimalPolynomials[0], minimalPolynomials[1]);
        for (int i = 2; i < minimalPolynomials.length; ++i)
            ext = ext.adjoinAlgebraicElement(minimalPolynomials[i]);
        return ext;
    }
}
